# The table below is used by glulx-to-c.py to generated C code.

# mnemonic          parameters sizes    code
accelfunc           ll        44        native_accelfunc(l1,l2);
accelparam          ll        44        native_accelparam(l1,l2);
add                 lls       444       s1 = l1 + l2;
aload               lls       444       s1 = ntohl(((uint32_t*)&mem[l1])[l2]);
aloadb              lls       444       s1 = mem[l1 + l2];
aloadbit            lls       444       s1 = mem[l1 + l2/8] >> (l2%8);
aloads              lls       444       s1 = ntohs(((uint16_t*)&mem[l1])[l2]);
astore              lll       444       ((uint32_t*)(mem + l1))[l2] = htonl(l3);
astoreb             lll       444       mem[l1 + l2] = l3;
astorebit           lll       444       int x=l1+l2/8, j=l2%8; mem[x]=(mem[x]&~(1<<j))|((l3 != 0)<<(j));
astores             lll       444       ((uint16_t*)(mem + l1))[l2] = htons(l3);
binarysearch        llllllls  44444444  s1 = native_binarysearch(l1,l2,l3,l4,l5,l6,l7);
bitand              lls       444       s1 = l1&l2;
bitnot              ls        44        s1 = ~l1;
bitor               lls       444       s1 = l1|l2;
call                lls       444       *sp = l2; s1 = func(l1)(sp); sp -= l2;
callf               ls        44        *sp = 0; s1 = func(l1)(sp);
callfi              lls       444       *sp++ = l2; *sp = 1; s1 = func(l1)(sp); sp -= 1;
callfii             llls      4444      *sp++ = l3; *sp++ = l2; *sp = 2; s1 = func(l1)(sp); sp -= 2;
callfiii            lllls     44444     *sp++ = l4; *sp++ = l3; *sp++ = l2; *sp = 3; s1 = func(l1)(sp); sp -= 3;
copy                ls        44        s1 = l1;
copyb               ls        11        s1 = l1;
copys               ls        22        s1 = l1;
div                 lls       444       s1 = (uint32_t)((int32_t)l1 / (int32_t)l2);
gestalt             lls       444       s1 = native_gestalt(l1, l2);
getmemsize          s         4         s1 = native_getmemsize();
glk                 lls       444       s1 = native_glk(l1, l2, &sp);
jeq                 llb       44x       if (l1 == l2) goto b1;
jge                 llb       44x       if ((int32_t)l1 >= (int32_t)l2) goto b1;
jgeu                llb       44x       if (l1 >= l2) goto b1;
jgt                 llb       44x       if ((int32_t)l1 > (int32_t)l2) goto b1;
jgtu                llb       44x       if (l1 > l2) goto b1;
jle                 llb       44x       if ((int32_t)l1 <= (int32_t)l2) goto b1;
jleu                llb       44x       if (l1 <= l2) goto b1;
jlt                 llb       44x       if ((int32_t)l1 < (int32_t)l2) goto b1;
jltu                llb       44x       if (l1 < l2) goto b1;
jne                 llb       44x       if (l1 != l2) goto b1;
jnz                 lb        4x        if (l1 != 0) goto b1;
jump                b         x         goto b1;
jz                  lb        4x        if (l1 == 0) goto b1;
malloc              ls        44        s1 = native_malloc(l1);
mcopy               lll       444       memmove(&mem[l3], &mem[l2], l1);
mfree               l         4         native_mfree(l1);
mod                 lls       444       s1 = (uint32_t)((int32_t)l1 / (int32_t)l2);
mul                 lls       444       s1 = l1 * l2;
mzero               ll        44        memset(&mem[l2], 0, l1);
neg                 ls        44        s1 = -l1;
nop                 -         -         ;
quit                -         -         native_quit();
random              ls        44        s1 = (uint32_t)native_random((int32_t)l1);
restart             -         -         native_restart();
restore             ls        44        s1 = native_restore(l1);
restoreundo         s         4         s1 = native_restoreundo();
ret                 l         4         return l1;
save                ls        44        s1 = native_save(l1);
saveundo            s         4         s1 = native_saveundo();
setiosys            ll        44        native_setiosys(l1, l2);
setrandom           l         4         native_setrandom(l1);
shiftl              lls       444       s1 = (l2 < 32) ? (l1 << l2) : 0;
stkcopy             l         4         int32_t n; for (n=0; n<(int32_t)l1; ++n) sp[n]=sp[n-(int32_t)l1]; sp+=n;
stkroll             ll        44        native_stkroll(l1, (int32_t)l2);
stkswap             -         -         uint32_t tmp = sp[-1]; sp[-1] = sp[-2]; sp[-2] = tmp;
streamchar          l         4         native_streamchar(l1);
streamnum           l         4         native_streamnum((int32_t)l1);
streamstr           l         4         native_streamstr(l1);
sub                 lls       444       s1 = l1 - l2;
ushiftr             lls       444       s1 = (l2 < 32) ? (l1 >> l2) : 0;
verify              s         4         s1 = native_verify();
