# The table below is used by glulx-to-c.py to generated C code.

# mnemonic          parameters sizes    code
accelfunc           ll        44        native_accelfunc(l1,l2);
accelparam          ll        44        native_accelparam(l1,l2);
add                 lls       444       s1 = l1 + l2;
aload               lls       444       s1 = get_long(l1 + 4*l2);
aloadb              lls       444       s1 = get_byte(l1 + l2);
aloadbit            lls       444       s1 = (get_byte(l1 + l2/8) >> (l2%8))&1;
aloads              lls       444       s1 = get_shrt(l1 + 2*l2);
astore              lll       444       set_long(l1 + 4*l2, l3);
astoreb             lll       444       set_byte(l1 + l2, l3);
astorebit           lll       444       int a = l1 + l2/8, b=l2%8; set_byte(a, (get_byte(a)&~(1<<b))|((l3 != 0)<<(b)));
astores             lll       444       set_shrt(l1 + 2*l2, l3);
binarysearch        llllllls  44444444  s1 = native_binarysearch(l1, l2, l3, l4, l5, l6, l7);
bitand              lls       444       s1 = l1&l2;
bitnot              ls        44        s1 = ~l1;
bitor               lls       444       s1 = l1|l2;
call                lls       444       *sp = l2; s1 = func(l1)(sp); sp -= l2;
callf               ls        44        *sp = 0; s1 = func(l1)(sp);
callfi              lls       444       *sp++ = l2; *sp = 1; s1 = func(l1)(sp); sp -= 1;
callfii             llls      4444      *sp++ = l3; *sp++ = l2; *sp = 2; s1 = func(l1)(sp); sp -= 2;
callfiii            lllls     44444     *sp++ = l4; *sp++ = l3; *sp++ = l2; *sp = 3; s1 = func(l1)(sp); sp -= 3;
copy                ls        44        s1 = l1;
copyb               ls        11        s1 = l1;
copys               ls        22        s1 = l1;
div                 lls       444       s1 = (uint32_t)((int32_t)l1 / (int32_t)l2);
gestalt             lls       444       s1 = native_gestalt(l1, l2);
getmemsize          s         4         s1 = native_getmemsize();
glk                 lls       444       s1 = native_glk(l1, l2, &sp);
jeq                 llb       44x       if (l1 == l2) b1;
jge                 llb       44x       if ((int32_t)l1 >= (int32_t)l2) b1;
jgeu                llb       44x       if (l1 >= l2) b1;
jgt                 llb       44x       if ((int32_t)l1 > (int32_t)l2) b1;
jgtu                llb       44x       if (l1 > l2) b1;
jle                 llb       44x       if ((int32_t)l1 <= (int32_t)l2) b1;
jleu                llb       44x       if (l1 <= l2) b1;
jlt                 llb       44x       if ((int32_t)l1 < (int32_t)l2) b1;
jltu                llb       44x       if (l1 < l2) b1;
jne                 llb       44x       if (l1 != l2) b1;
jnz                 lb        4x        if (l1 != 0) b1;
jump                b         x         b1;
jz                  lb        4x        if (l1 == 0) b1;
linearsearch        llllllls  44444444  s1 = native_linearsearch(l1, l2, l3, l4, l5, l6, l7);
malloc              ls        44        s1 = native_malloc(l1);
mcopy               lll       444       memmove(&mem[l3], &mem[l2], l1);
mfree               l         4         native_mfree(l1);
mod                 lls       444       s1 = (uint32_t)((int32_t)l1 % (int32_t)l2);
mul                 lls       444       s1 = l1 * l2;
mzero               ll        44        memset(&mem[l2], 0, l1);
neg                 ls        44        s1 = -l1;
nop                 -         -         ;
quit                -         -         native_quit();
random              ls        44        s1 = (uint32_t)native_random((int32_t)l1);
restart             -         -         native_restart();
restore             ls        44        s1 = native_restore(l1);
restoreundo         s         4         s1 = native_restoreundo();
ret                 l         4         return l1;
save                ls        44        s1 = native_save(l1);
saveundo            s         4         s1 = native_saveundo();
setiosys            ll        44        native_setiosys(l1, l2);
setrandom           l         4         native_setrandom(l1);
shiftl              lls       444       s1 = (l2 < 32) ? (l1 << l2) : 0;
sshiftr             lls       444       s1 = (l2 < 32) ? ((int32_t)l1 >> l2) : 0;
stkcopy             l         4         int32_t n; for (n = 0; n < (int32_t)l1; ++n) sp[n] = sp[n - (int32_t)l1]; sp += l1;
stkroll             ll        44        native_stkroll(l1, (int32_t)l2, sp);
stkswap             -         -         uint32_t tmp = sp[-1]; sp[-1] = sp[-2]; sp[-2] = tmp;
streamchar          l         4         native_streamchar(l1);
streamnum           l         4         native_streamnum((int32_t)l1);
streamstr           l         4         native_streamstr(l1);
sub                 lls       444       s1 = l1 - l2;
ushiftr             lls       444       s1 = (l2 < 32) ? (l1 >> l2) : 0;
verify              s         4         s1 = native_verify();
